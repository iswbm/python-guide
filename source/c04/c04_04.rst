4.4 【进阶】五种推导式
======================

推导式（英文名：comprehensions），也叫解析式，是Python的一种独有特性。

推导式是可以从一个数据序列构建另一个新的数据序列的结构体。

总共有四种推导式：

1. 列表(list)推导式

2. 字典(dict)推导式

3. 集合(set)推导式
4. 生成器推导式

1. 列表推导式
-------------

列表推导式的基本格式

.. code:: python

   new_list = [expression for_loop_expression if condition]

举个例子。

我想找出一个数值列表中为偶数的元素，并组成新列表，通常不用列表推导式，可以这么写

.. code:: python

   old_list = [0,1,2,3,4,5]

   new_list = []
   for item in old_list:
       if item % 2 == 0:
           new_list.append(item)

   print(new_list) # output: [0, 2, 4]

一个简单的功能，写的代码倒是不少。

如果使用了列表推导式，那就简洁多了，而且代码还变得更加易读了。

.. code:: python

   >>> old_list = [0,1,2,3,4,5]
   >>>
   >>> new_list = [item for item in old_list if item % 2 == 0]
   >>> print(new_list) # output: [0, 2, 4]
   [0, 2, 4]

2. 字典推导式
-------------

列表推导式的基本格式，和 列表推导式相似，只是把 ``[]`` 改成了
``{}``\ ，并且组成元素有两个：key 和 value，要用
``key_expr: value_expr`` 表示。

.. code:: python

   new_dict ={ key_expr: value_expr for_loop_expression if condition }

举个例子。

我想从一个包含所有学生成绩信息的字典中，找出数学考满分的同学。

.. code:: python

   old_student_score_info = {
       "Jack": {
           "chinese": 87,
           "math": 92,
           "english": 78
       },
       "Tom": {
           "chinese": 92,
           "math": 100,
           "english": 89
       }
   }

   new_student_score_info = {name: scores for name, scores in old_student_score_info.items() if scores["math"] == 100}
   print(new_student_score_info)
   # output: {'Tom': {'chinese': 92, 'math': 100, 'english': 89}}

3. 集合推导式
-------------

集合推导式跟列表推导式也是类似的。
唯一的区别在于它使用大括号\ ``{}``\ ，组成元素也只要一个。

基本格式

.. code:: python

   new_set = { expr for_loop_expression if condition }

举个例子

我想把一个数值列表里的数进行去重处理

.. code:: python

   >>> old_list = [0,0,0,1,2,3]
   >>>
   >>> new_set = {item for item in old_list}
   >>> print(new_set)
   {0, 1, 2, 3}

4. 生成器推导式
---------------

生成器推导式跟列表推导式，非常的像，只是把 ``[]`` 换成了 ``()``

-  列表推导式：生成的是新的列表
-  生成器推导式：生成的是一个生成器

直接上案例了，找出一个数值列表中所有的偶数

.. code:: python

   >>> old_list = [0,1,2,3,4,5]
   >>> new_list = (item for item in old_list if item % 2 == 0)
   >>> new_list
   <generator object <genexpr> at 0x10292df10>
   >>> next(new_list)
   0
   >>> next(new_list)
   2

5. 嵌套推导式
-------------

for
循环可以有两层，甚至更多层，同样的，上面所有的推导式，其实都可以写成嵌套的多层推导式。

但建议最多嵌套两层，最多的话，代码就会变得非常难以理解。

举个例子。

我想打印一个乘法表，使用两个for可以这样写

.. code:: python

   for i in range(1, 10):
       for j in range(1, i+1):
           print('{}x{}={}\t'.format(j, i, i*j), end='')
       print("")

输出如下

::

   1x1=1   
   1x2=2   2x2=4   
   1x3=3   2x3=6   3x3=9   
   1x4=4   2x4=8   3x4=12  4x4=16  
   1x5=5   2x5=10  3x5=15  4x5=20  5x5=25  
   1x6=6   2x6=12  3x6=18  4x6=24  5x6=30  6x6=36  
   1x7=7   2x7=14  3x7=21  4x7=28  5x7=35  6x7=42  7x7=49  
   1x8=8   2x8=16  3x8=24  4x8=32  5x8=40  6x8=48  7x8=56  8x8=64  
   1x9=9   2x9=18  3x9=27  4x9=36  5x9=45  6x9=54  7x9=63  8x9=72  9x9=81

如果使用嵌套的列表推导式，可以这么写

.. code:: python

   >>> print('\n'.join([' '.join(['%2d *%2d = %2d' % (col, row, col * row) for col in range(1, row + 1)]) for row in range(1, 10)]))
    1 * 1 =  1
    1 * 2 =  2  2 * 2 =  4
    1 * 3 =  3  2 * 3 =  6  3 * 3 =  9
    1 * 4 =  4  2 * 4 =  8  3 * 4 = 12  4 * 4 = 16
    1 * 5 =  5  2 * 5 = 10  3 * 5 = 15  4 * 5 = 20  5 * 5 = 25
    1 * 6 =  6  2 * 6 = 12  3 * 6 = 18  4 * 6 = 24  5 * 6 = 30  6 * 6 = 36
    1 * 7 =  7  2 * 7 = 14  3 * 7 = 21  4 * 7 = 28  5 * 7 = 35  6 * 7 = 42  7 * 7 = 49
    1 * 8 =  8  2 * 8 = 16  3 * 8 = 24  4 * 8 = 32  5 * 8 = 40  6 * 8 = 48  7 * 8 = 56  8 * 8 = 64
    1 * 9 =  9  2 * 9 = 18  3 * 9 = 27  4 * 9 = 36  5 * 9 = 45  6 * 9 = 54  7 * 9 = 63  8 * 9 = 72  9 * 9 = 81
